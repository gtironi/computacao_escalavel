#include <iostream>
#include <memory>
#include <string>
#include <grpcpp/grpcpp.h>
#include "mock_server/proto/extractor.pb.h" // Generated by protoc
#include "mock_server/proto/extractor.grpc.pb.h" // Generated by protoc-gen-grpc

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using extractor::ExtractorService;
using extractor::FlightRow;
using extractor::ReservaRow;
using extractor::PesquisaRow;
using extractor::AllDataSend;
using extractor::AllDataResponse;

// Logic and data behind the server's behavior.
class ExtractorServiceImpl final : public ExtractorService::Service {
    Status GetAllData(ServerContext* context, const AllDataSend* request,
                      AllDataResponse* response) override {
        // Calculate counts from the received request
        int32_t flight_count = request->voos_size();
        int32_t reserva_count = request->reservas_size();
        int32_t pesquisa_count = request->pesquisas_size();

        // Populate the response with counts
        response->set_stats1(flight_count);
        response->set_stats2(reserva_count);
        response->set_stats3(pesquisa_count);

        // For stats4 and stats5, you requested "repeated sums".
        // Let's make them sums of the counts for demonstration.
        int32_t total_count_sum = flight_count + reserva_count + pesquisa_count;
        response->set_stats4(total_count_sum);
        response->set_stats5(total_count_sum); // Repeated sum as requested

        std::cout << "Server received AllDataSend:" << std::endl;
        std::cout << "  Flights: " << flight_count << std::endl;
        std::cout << "  Reservations: " << reserva_count << std::endl;
        std::cout << "  Searches: " << pesquisa_count << std::endl;
        std::cout << "Server sending AllDataResponse:" << std::endl;
        std::cout << "  Stats1 (Flights): " << response->stats1() << std::endl;
        std::cout << "  Stats2 (Reservations): " << response->stats2() << std::endl;
        std::cout << "  Stats3 (Searches): " << response->stats3() << std::endl;
        std::cout << "  Stats4 (Total Sum): " << response->stats4() << std::endl;
        std::cout << "  Stats5 (Total Sum - Repeated): " << response->stats5() << std::endl;
        std::cout << "-----------------------------------" << std::endl;

        return Status::OK;
    }
};

void RunServer() {
    std::string server_address("0.0.0.0:50051");
    ExtractorServiceImpl service;

    ServerBuilder builder;
    builder.SetMaxReceiveMessageSize(50 * 1024 * 1024); // 50 MB
    // Listen on the given address without any authentication mechanism.
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    // Register "service" as the instance through which we'll perform
    // the actual work.
    builder.RegisterService(&service);
    // Finally, assemble the server.
    std::unique_ptr<Server> server(builder.BuildAndStart());
    std::cout << "Server listening on " << server_address << std::endl;

    // Wait for the server to shutdown. Note that some other thread must be
    // responsible for shutting down the server for this call to ever return.
    server->Wait();
}

int main() {
    RunServer();
    return 0;
}